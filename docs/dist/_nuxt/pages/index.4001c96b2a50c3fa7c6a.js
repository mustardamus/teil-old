webpackJsonp([1],{"7TCL":function(e,a,s){"use strict";Object.defineProperty(a,"__esModule",{value:!0});var t=s("yFkh"),n=s("MT1B"),o=s("VU/8")(t.a,n.a,!1,null,null,null);o.options.__file="docs/pages/index.vue",a.default=o.exports},G0wi:function(e,a){e.exports='<section><h1>Teil</h1>\n<p>Developer friendly \'get shit done\' Node.js web framework based on\n<a href="https://expressjs.com/">Express.js</a> and <a href="https://www.mongodb.com/">MongoDB</a> via\n<a href="http://mongoosejs.com/">Mongoose</a>. Comes with batteries and charger - quickly\nsketch a working API server and get your MVP up and running in no-time.</p>\n<h2>Features</h2>\n<h3>Get started with a new project in under a minute</h3>\n<p>Initialize a new Node.js project and install Teil:</p>\n<pre><code class="hljs language-shell">mkdir teil-blog\ncd teil-blog\nnpm init -y\nnpm install teil\n</code></pre>\n<p>Add the <code>dev</code> command to <code>package.json</code>:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">"scripts"</span>: {\n  <span class="hljs-string">"dev"</span>: <span class="hljs-string">"teil"</span>\n}\n</code></pre>\n<p>And start Teil with the <code>dev</code> command:</p>\n<pre><code class="hljs language-shell">npm run dev\n</code></pre>\n<p>From here on you do not need to restart the server. Every changes you make, like\nadding new routes, will be automatically applied.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/installation">Read more about Installation</a></h4>\n<h3>Create new routes and models by simply creating files</h3>\n<p>Sketching out new routes that will be instantly available only takes a couple of\nseconds.</p>\n<p>Lets say we want to create a RESTful API for blog articles. Simply create a file\nnamed <code>articles.js</code> in the <code>controllers</code> directory:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./controllers/articles.js</span>\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-string">\'GET /\'</span> ({ send }) {\n    send(<span class="hljs-string">\'Here will be a RESTful API...\'</span>)\n  }\n}\n</code></pre>\n<p>Without the need to restart the server you can browse to\n<a href="http://localhost:3003/api/articles">localhost:3003/api/articles</a> and see the\noutput from above. You can change the response string and the route will\nautomatically update!</p>\n<p>Creating models is equally easy. Create a file named <code>article.js</code> in the\n<code>models</code> directory:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./models/article.js</span>\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">schema</span>: {\n    <span class="hljs-attr">title</span>: <span class="hljs-built_in">String</span>,\n    <span class="hljs-attr">content</span>: <span class="hljs-built_in">String</span>\n  }\n}\n</code></pre>\n<p>Same game, change something in the model and Teil will automatically apply the\nchanges. Good bye server reload!</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/create-controllers-and-models">Read more about Create Controllers And Models</a></h4>\n<h3>Automatically starting MongoDB</h3>\n<p>When you started Teil, there were no models and hence no database connection was\nneeded. You can use Teil just fine without any database.</p>\n<p>But when you\'ve created the <code>Article</code> model, Teil checked if you have a MongoDB\nrunning. If not, it would start it automatically for you by forking a new\n<code>mongod</code> process.</p>\n<p>All relevant database files are saved in your project folder under <code>./db</code>, that\nmeans everything is in one place.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/database-connection">Read more about Database Connection</a></h4>\n<h3>Models are instantly usable in controllers</h3>\n<p>Now lets actually use the <code>Article</code> model in a route. We can use\nthe ES2016 destructuring feature like we did with the <code>send</code> method (more on\nthat later).</p>\n<p>Update the <code>GET /</code> route in <code>./controllers/articles.js</code> like so:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'GET /\'</span> ({ send, Article }) {\n  Article.find().exec().then(<span class="hljs-function"><span class="hljs-params">articles</span> =&gt;</span> send(articles))\n}\n</code></pre>\n<p>As you can see Teil did some wiring for us and mapped the file\n<code>./models/article.js</code> to the <code>Article</code> variable.</p>\n<p>This is a\n<a href="http://mongoosejs.com/docs/models.html">Mongoose Model</a> with every feature\nMongoose provides. In this example it finds any <code>Article</code> and responds the\nresult.</p>\n<p>Navigate to <a href="http://localhost:3003/api/articles">localhost:3003/api/articles</a>\nand you will see an empty Array, because there are no articles yet in the\ndatabase.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/models-to-controllers-wiring">Read more about Models To Controllers Wiring</a></h4>\n<h3>Using middlewares in routes</h3>\n<p>Since Teil is based on Express.js, you can use any compatible middleware,\nglobally (more on that later) or for specific routes.</p>\n<p>Lets see that in action by adding a <code>POST /</code> route to the\n<code>./controllers/authors.js</code> file:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'POST /\'</span>: [\n  <span class="hljs-function">(<span class="hljs-params">{ next, log }</span>) =&gt;</span> { <span class="hljs-comment">// route middlewares can use destructuring too</span>\n    log(<span class="hljs-string">\'Route Middleware #1\'</span>)\n    next()\n  },\n  (req, res, next) =&gt; { <span class="hljs-comment">// or the traditional express.js callback style</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Route Middleware #2\'</span>)\n    next()\n  },\n  ({ send }) =&gt; {\n    send(<span class="hljs-string">\'Here will be the create endpoint...\'</span>)\n  }\n]\n</code></pre>\n<p>As you can see, for this route we are defining an Array instead of a Function.\nEach item can be a middleware Function, the last item is the route handler.</p>\n<p>You can make use of destructuring in the middleware just as in the route\nhandler, as seen in the first middleware that uses Teil\'s logger (more on that\nlater), or use the traditional <code>(req, res, next)</code> middleware style.</p>\n<p>By the way, you can use the traditional <code>(req, res)</code> style in the route handler\nas well, however, using the destructuring style looks pretty sweet and brings\nsome additional features as we will see later.</p>\n<p>Lets try out the new route by using <code>curl</code>:</p>\n<pre><code class="hljs language-shell">curl -H "Content-Type: application/json" \\\n     -X POST http://localhost:3003/api/articles\n</code></pre>\n<p>You\'ll see a pretty log of the first, and a regular log of the second\nmiddleware. The server returns as expected the response string.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/routes-middleware">Read more about Routes Middleware</a></h4>\n<h3>Validate data before it arrives at the route</h3>\n<p>When we created the <code>Article</code> model, we didn\'t add any validation to it (more on\nmodel validation later), that means one could add an article without a <code>title</code>\nand <code>content</code>.</p>\n<p>Lets change that by validating the data that is arriving at the server. If the\nvalidation fails, the route handler isn\'t even called.</p>\n<p>Let\'s change the <code>POST /</code> route of <code>./controllers/articles.js</code>:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'POST /\'</span>: [\n  {\n    <span class="hljs-attr">body</span>: {\n      <span class="hljs-attr">title</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n      <span class="hljs-attr">content</span>: <span class="hljs-string">\'isNotEmpty\'</span>\n    }\n  },\n\n  ({ next }) =&gt; next(), <span class="hljs-comment">// middleware #1</span>\n  (req, res, next) =&gt; next(), <span class="hljs-comment">// middleware #2</span>\n\n  ({ send, body, Article }) =&gt; {\n    <span class="hljs-keyword">const</span> article = <span class="hljs-keyword">new</span> Article(body)\n    article.save().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> send(article))\n  }\n]\n</code></pre>\n<p>For clarity, the middlewares have been compressed. What\'s new in the route\nhandler (always the last item in the Array) is that we grab the <code>body</code> (the\npayload of the <code>POST</code> request) and the <code>Article</code> model. We create a new\n<a href="http://mongoosejs.com/docs/api.html#Document">Mongoose Document</a>, save and\nreturn it.</p>\n<p>Note the first Object of the Array. There we define a <code>body</code> field, which is a\nvalidation schema used by the\n<a href="https://github.com/ianstormtaylor/superstruct">Superstruct</a> library. With the\n<code>isNotEmpty</code> rule we say that both <code>title</code> and <code>content</code> of the <code>body</code> can not\nbe empty.</p>\n<p>Lets try creating an article without content:</p>\n<pre><code class="hljs language-shell">curl -H "Content-Type: application/json" \\\n     -d \'{"title":"Example Post","content":""}\' \\\n     -X POST http://localhost:3003/api/articles\n</code></pre>\n<p>The request will fail with a status code of <code>500</code> and returns:</p>\n<pre><code class="hljs language-shell">Expected a value of type `isNotEmpty` for `content` but received `""`.\n</code></pre>\n<p>Sweet! Lets try the same request but with some content - as expected it returns\nthe created document:</p>\n<pre><code class="hljs language-javascript">{\n  <span class="hljs-string">"_id"</span>:<span class="hljs-string">"5a6b899b03d643073d58ab2e"</span>,\n  <span class="hljs-string">"title"</span>:<span class="hljs-string">"Example Post"</span>,\n  <span class="hljs-string">"content"</span>:<span class="hljs-string">"Example Content"</span>,\n  <span class="hljs-string">"__v"</span>:<span class="hljs-number">0</span>\n}\n</code></pre>\n<h4><a href="https://mustardamus.github.io/teil/guide/route-data-validation">Read more about Route Data Validation</a></h4>\n<h3>Data validation in model schemas</h3>\n<p>Mongoose supports\n<a href="http://mongoosejs.com/docs/validation.html#custom-validators">custom validations</a>\nout of the box. Teil extends this with many validations provided by\n<a href="https://github.com/chriso/validator.js">Validator.js</a>.</p>\n<p>Lets add a optional <code>authorEmail</code> field to the <code>Author</code> model at\n<code>./models/author.js</code>:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./models/article.js</span>\n<span class="hljs-built_in">module</span>.exports = {\n  schema ({ <span class="hljs-attr">validator</span>: { isEmail } }) {\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">title</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },\n      <span class="hljs-attr">content</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },\n\n      <span class="hljs-attr">authorEmail</span>: {\n        <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,\n        <span class="hljs-attr">validate</span>: {\n          <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.length === <span class="hljs-number">0</span> || isEmail(val),\n          <span class="hljs-attr">message</span>: <span class="hljs-string">\'{VALUE} is not a valid E-Mail\'</span>\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>As you can see, the <code>schema</code> isn\'t an Object anymore, but a Function that is\nusing destructuring again. This Function must return the schema Object.</p>\n<p>For <code>title</code> and <code>content</code> the <code>required</code> validation that Mongoose is providing\nis used.</p>\n<p>We added a new <code>authorEmail</code> field. There we make use of Mongoose\'s custom\nvalidations. On top of that we use the <code>isEmail</code> validator from Validator.js,\nand make it optional by checking the length of the string.</p>\n<p>Since we already validating data on the route, we need to extend that schema as\nwell, in <code>./controllers/authors.js</code>:</p>\n<pre><code class="hljs language-javascript">body: {\n  <span class="hljs-attr">title</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n  <span class="hljs-attr">content</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n  <span class="hljs-attr">authorEmail</span>: <span class="hljs-string">\'string?\'</span>\n}\n</code></pre>\n<p>The <code>?</code> tells Superstruct that the value of <code>authorEmail</code> is an optional String.</p>\n<p>Lets try creating an article with an invalid <code>authorEmail</code>:</p>\n<pre><code class="hljs language-shell">curl -H "Content-Type: application/json" \\\n     -d \'{"title":"Example Post","content":"Example Content","authorEmail":"nope"}\' \\\n     -X POST http://localhost:3003/api/articles\n</code></pre>\n<p>This request is failing with a status code of <code>500</code> and is returning:</p>\n<pre><code class="hljs language-shell">Article validation failed: authorEmail: nope is not a valid E-Mail\n</code></pre>\n<p>Posting no <code>authorEmail</code> or a valid E-Mail works fine. Easy peasy.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/model-schema-validation">Read more about Model Schema Validation</a></h4>\n<h3>Create fully fledged Mongoose models by simple declarative objects</h3>\n<p>Mongoose models are powerful. Teil adds some abstraction to all the features and\nmakes it pretty simple to define fully fledged models.</p>\n<p>Lets add a <a href="http://mongoosejs.com/docs/api.html#Virtualtype">virtual field</a>\n<code>excerpt</code> for example by adding this to <code>./models/article.js</code>:</p>\n<pre><code class="hljs language-javascript">virtuals: {\n  <span class="hljs-attr">excerpt</span>: {\n    get () {\n      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.content === <span class="hljs-string">\'string\'</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.content.substr(<span class="hljs-number">0</span>, <span class="hljs-number">140</span>) + <span class="hljs-string">\'...\'</span>\n      }\n    }\n  }\n},\n\n<span class="hljs-attr">options</span>: {\n  <span class="hljs-attr">toObject</span>: { <span class="hljs-attr">virtuals</span>: <span class="hljs-literal">true</span> }\n}\n</code></pre>\n<p>Here <code>virtuals</code> is an Object that holds all virtual fields, the key name is also\nthe name of the virtual field, <code>excerpt</code> in this example. This field has a\ngetter, represented by the <code>get()</code> method.</p>\n<p>In this method we check if the type <code>content</code> of the document (<code>this</code>) is a\nString (remember, we\'ve created articles without content), and if so, return\nthe first 140 characters of the <code>content</code> value.</p>\n<p>Below the <code>virtuals</code> there is an <code>options</code> Object defined. We want the excerpt\nto be included when we return the document in JSON format. Therefore we set\nthe <code>virtuals</code> option of\n<a href="http://mongoosejs.com/docs/api.html#document_Document-toObject">toObject</a> to\n<code>true</code>.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/model-declaration">Read more about Model Declaration</a></h4>\n<h3>Validate and alter response data before it\'s leaving the route</h3>\n<p>Since we now have the <code>excerpt</code> field, we don\'t necessarily want to return the\n<code>content</code> of an article when listing all articles. Let\'s edit the <code>GET /</code> route\nof <code>./controllers/articles.js</code> like this:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'GET /\'</span>: [\n  {\n    response ({ data, <span class="hljs-attr">_</span>: { pick }}) {\n      <span class="hljs-keyword">return</span> data.map(<span class="hljs-function"><span class="hljs-params">article</span> =&gt;</span> pick(article, [<span class="hljs-string">\'_id\'</span>, <span class="hljs-string">\'title\'</span>, <span class="hljs-string">\'excerpt\'</span>]))\n    }\n  },\n\n  ({ send, Article }) =&gt; {\n    Article.find().exec().then(<span class="hljs-function"><span class="hljs-params">articles</span> =&gt;</span> send(articles))\n  }\n]\n</code></pre>\n<p>The <code>GET /</code> Function became an Array. The validation schema Object is the first\nitem of that Array, the route handler Function is the second.</p>\n<p>Here we could have defined an Object for the <code>response</code> validation schema, like\nwe saw before with <code>body</code>. Instead we pass an custom method. Via destructuring\nwe pick the <code>data</code> (that is the data that we responded with <code>send()</code>) as well as\nthe <a href="https://lodash.com/docs/4.17.4#pick">pick</a> method of Lodash.</p>\n<p>We map over each article and pick only the <code>_id</code>, <code>title</code> and <code>excerpt</code> fields.\nThen we return the newly Array.</p>\n<p>As stated before, this is an additional feature of the destructured <code>send()</code>\nmethod. It would not work with the regular <code>res.send()</code> or <code>res.json()</code> of\nExpress.js.</p>\n<p>When we navigate to the\n<a href="http://localhost:3003/api/articles">localhost:3003/api/articles</a> URL we will\nsee the trimmed down articles:</p>\n<pre><code class="hljs language-javascript">[\n  {\n    <span class="hljs-string">"_id"</span>: <span class="hljs-string">"5a6b90d303d643073d58ab39"</span>,\n    <span class="hljs-string">"title"</span>: <span class="hljs-string">"Example Post"</span>,\n    <span class="hljs-string">"excerpt"</span>: <span class="hljs-string">"Example Content..."</span>\n  }\n]\n</code></pre>\n<p>This is a super neat way of staying in control which data is leaving your API.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/validate-and-alter-response-data">Read more about Validate And Alter Response Data</a></h4>\n<h3>Tight controllers by using destructuring</h3>\n<h4><a href="https://mustardamus.github.io/teil/guide/route-handler-context">Read more about Route Handler Context</a></h4>\n<h3>Automatically load global middleware</h3>\n<h4><a href="https://mustardamus.github.io/teil/guide/global-middleware">Read more about Global Middleware</a></h4>\n<h3>Automatically serving static files</h3>\n<h4><a href="https://mustardamus.github.io/teil/guide/static-files">Read more about Static Files</a></h4>\n<h3>Lovely logging</h3>\n<h4><a href="https://mustardamus.github.io/teil/guide/lovely-logging">Read more about Lovely Logging</a></h4>\n<h3>All configurable via a single config file</h3>\n<h4><a href="https://mustardamus.github.io/teil/guide/single-file-configuration">Read more about Single File Configuration</a></h4>\n<h3>And some more features to save you time</h3>\n<h4><a href="https://mustardamus.github.io/teil/guide/extended-superstruct">Read more about Extended Superstruct</a></h4>\n<h2>Development</h2>\n<h3>Commands (<code>yarn *</code>)</h3>\n<h4><code>test</code></h4>\n<p>Runs the tests.</p>\n<h4><code>test:watch</code></h4>\n<p>Re-run tests on file changes.</p>\n<h4><code>lint</code></h4>\n<p>Linting all the code.</p>\n<h4><code>docs:dev</code></h4>\n<p>Starts the <code>./docs</code> Nuxt app on <a href="http://localhost:9991">localhost:9991</a>.</p>\n<h4><code>docs:generate</code></h4>\n<p>Generate a static version of the documentation.</p>\n<h4><code>docs:publish</code></h4>\n<p>Publish the generated documentation to <code>gh-pages</code>.</p>\n<h4><code>docs</code></h4>\n<p>Run <code>docs:generate</code> and <code>docs:publish</code> in sequence.</p>\n<h3><code>example</code></h3>\n<p>Runs the full example in <code>./example</code>.</p>\n</section>\n'},MT1B:function(e,a,s){"use strict";var t=function(){var e=this.$createElement;return(this._self._c||e)("div",{domProps:{innerHTML:this._s(this.readMe)}})};t._withStripped=!0;var n={render:t,staticRenderFns:[]};a.a=n},yFkh:function(e,a,s){"use strict";var t=s("G0wi"),n=s.n(t);a.a={computed:{readMe:function(){return n.a}}}}});
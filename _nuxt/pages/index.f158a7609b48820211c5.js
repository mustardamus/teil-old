webpackJsonp([1],{"7TCL":function(e,s,a){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var n=a("yFkh"),t=a("MT1B"),o=a("VU/8")(n.a,t.a,!1,null,null,null);o.options.__file="docs/pages/index.vue",s.default=o.exports},G0wi:function(e,s){e.exports='<section><h1>Teil</h1>\n<p>Developer friendly \'get shit done\' Node.js web framework based on\n<a href="https://expressjs.com/">Express.js</a> and <a href="https://www.mongodb.com/">MongoDB</a> via\n<a href="http://mongoosejs.com/">Mongoose</a>. Comes with batteries and charger - quickly\nsketch a working API server and get your MVP up and running in no-time.</p>\n<h2>Features</h2>\n<h3>Get started with a new project in under a minute</h3>\n<p>Initialize a new Node.js project and install Teil:</p>\n<pre><code class="hljs language-shell">mkdir teil-blog\ncd teil-blog\nnpm init -y\nnpm install teil\n</code></pre>\n<p>Add the <code>dev</code> command to <code>package.json</code>:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">"scripts"</span>: {\n  <span class="hljs-string">"dev"</span>: <span class="hljs-string">"teil"</span>\n}\n</code></pre>\n<p>And start Teil with the <code>dev</code> command:</p>\n<pre><code class="hljs language-shell">npm run dev\n</code></pre>\n<p>From here on you do not need to restart the server. Every changes you make, like\nadding new routes, will be automatically applied.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/installation">Read more about Installation</a></h4>\n<h3>Create new routes and models by simply creating files</h3>\n<p>Sketching out new routes that will be instantly available only takes a couple of\nseconds.</p>\n<p>Lets say we want to create a RESTful API for blog articles. Simply create a file\nnamed <code>articles.js</code> in the <code>controllers</code> directory:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./controllers/articles.js</span>\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-string">\'GET /\'</span> ({ send }) {\n    send(<span class="hljs-string">\'Here will be a RESTful API...\'</span>)\n  }\n}\n</code></pre>\n<p>Without the need to restart the server you can browse to\n<a href="http://localhost:3003/api/articles">localhost:3003/api/articles</a> and see the\noutput from above. You can change the response string and the route will\nautomatically update!</p>\n<p>Creating models is equally easy. Create a file named <code>article.js</code> in the\n<code>models</code> directory:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./models/article.js</span>\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">schema</span>: {\n    <span class="hljs-attr">title</span>: <span class="hljs-built_in">String</span>,\n    <span class="hljs-attr">content</span>: <span class="hljs-built_in">String</span>\n  }\n}\n</code></pre>\n<p>Same game, change something in the model and Teil will automatically apply the\nchanges. Good bye server reload!</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/create-controllers-and-models">Read more about Create Controllers And Models</a></h4>\n<h3>Automatically starting MongoDB</h3>\n<p>When you started Teil, there were no models and hence no database connection was\nneeded. You can use Teil just fine without any database.</p>\n<p>But when you\'ve created the <code>Article</code> model, Teil checked if you have a MongoDB\nrunning. If not, it would start it automatically for you by forking a new\n<code>mongod</code> process.</p>\n<p>All relevant database files are saved in your project folder under <code>./db</code>, that\nmeans everything is in one place.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/database-connection">Read more about Database Connection</a></h4>\n<h3>Models are instantly usable in controllers</h3>\n<p>Now lets actually use the <code>Article</code> model in a route. We can use\nthe ES2016 destructuring feature like we did with the <code>send</code> method (more on\nthat later).</p>\n<p>Update the <code>GET /</code> route in <code>./controllers/articles.js</code> like so:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'GET /\'</span> ({ send, Article }) {\n  Article.find().exec().then(<span class="hljs-function"><span class="hljs-params">articles</span> =&gt;</span> send(articles))\n}\n</code></pre>\n<p>As you can see Teil did some wiring for us and mapped the file\n<code>./models/article.js</code> to the <code>Article</code> variable.</p>\n<p>This is a\n<a href="http://mongoosejs.com/docs/models.html">Mongoose Model</a> with every feature\nMongoose provides. In this example it finds any <code>Article</code> and responds the\nresult.</p>\n<p>Navigate to <a href="http://localhost:3003/api/articles">localhost:3003/api/articles</a>\nand you will see an empty Array, because there are no articles yet in the\ndatabase.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/models-to-controllers-wiring">Read more about Models To Controllers Wiring</a></h4>\n<h3>Using middlewares in routes</h3>\n<p>Since Teil is based on Express.js, you can use any compatible middleware,\nglobally (more on that later) or for specific routes.</p>\n<p>Lets see that in action by adding a <code>POST /</code> route to the\n<code>./controllers/authors.js</code> file:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'POST /\'</span>: [\n  <span class="hljs-function">(<span class="hljs-params">{ next, log }</span>) =&gt;</span> { <span class="hljs-comment">// route middlewares can use destructuring too</span>\n    log(<span class="hljs-string">\'Route Middleware #1\'</span>)\n    next()\n  },\n  (req, res, next) =&gt; { <span class="hljs-comment">// or the traditional express.js callback style</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Route Middleware #2\'</span>)\n    next()\n  },\n  ({ send }) =&gt; {\n    send(<span class="hljs-string">\'Here will be the create endpoint...\'</span>)\n  }\n]\n</code></pre>\n<p>As you can see, for this route we are defining an Array instead of a Function.\nEach item can be a middleware Function, the last item is the route handler.</p>\n<p>You can make use of destructuring in the middleware just as in the route\nhandler, as seen in the first middleware that uses Teil\'s logger (more on that\nlater), or use the traditional <code>(req, res, next)</code> middleware style.</p>\n<p>By the way, you can use the traditional <code>(req, res)</code> style in the route handler\nas well, however, using the destructuring style looks pretty sweet and brings\nsome additional features as we will see later.</p>\n<p>Lets try out the new route by using <code>curl</code>:</p>\n<pre><code class="hljs language-shell">curl -H "Content-Type: application/json" \\\n     -X POST http://localhost:3003/api/articles\n</code></pre>\n<p>You\'ll see a pretty log of the first, and a regular log of the second\nmiddleware. The server returns as expected the response string.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/routes-middleware">Read more about Routes Middleware</a></h4>\n<h3>Validate data before it arrives at the route</h3>\n<p>When we created the <code>Article</code> model, we didn\'t add any validation to it (more on\nmodel validation later), that means one could add an article without a <code>title</code>\nand <code>content</code>.</p>\n<p>Lets change that by validating the data that is arriving at the server. If the\nvalidation fails, the route handler isn\'t even called.</p>\n<p>Let\'s change the <code>POST /</code> route of <code>./controllers/articles.js</code>:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'POST /\'</span>: [\n  {\n    <span class="hljs-attr">body</span>: {\n      <span class="hljs-attr">title</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n      <span class="hljs-attr">content</span>: <span class="hljs-string">\'isNotEmpty\'</span>\n    }\n  },\n\n  ({ next }) =&gt; next(), <span class="hljs-comment">// middleware #1</span>\n  (req, res, next) =&gt; next(), <span class="hljs-comment">// middleware #2</span>\n\n  ({ send, body, Article }) =&gt; {\n    <span class="hljs-keyword">const</span> article = <span class="hljs-keyword">new</span> Article(body)\n    article.save().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> send(article))\n  }\n]\n</code></pre>\n<p>For clarity, the middlewares have been compressed. What\'s new in the route\nhandler (always the last item in the Array) is that we grab the <code>body</code> (the\npayload of the <code>POST</code> request) and the <code>Article</code> model. We create a new\n<a href="http://mongoosejs.com/docs/api.html#Document">Mongoose Document</a>, save and\nreturn it.</p>\n<p>Note the first Object of the Array. There we define a <code>body</code> field, which is a\nvalidation schema used by the\n<a href="https://github.com/ianstormtaylor/superstruct">Superstruct</a> library. With the\n<code>isNotEmpty</code> rule we say that both <code>title</code> and <code>content</code> of the <code>body</code> can not\nbe empty.</p>\n<p>Lets try creating an article without content:</p>\n<pre><code class="hljs language-shell">curl -H "Content-Type: application/json" \\\n     -d \'{"title":"Example Post","content":""}\' \\\n     -X POST http://localhost:3003/api/articles\n</code></pre>\n<p>The request will fail with a status code of <code>500</code> and returns:</p>\n<pre><code class="hljs language-shell">Expected a value of type `isNotEmpty` for `content` but received `""`.\n</code></pre>\n<p>Sweet! Lets try the same request but with some content - as expected it returns\nthe created document:</p>\n<pre><code class="hljs language-javascript">{\n  <span class="hljs-string">"_id"</span>:<span class="hljs-string">"5a6b899b03d643073d58ab2e"</span>,\n  <span class="hljs-string">"title"</span>:<span class="hljs-string">"Example Post"</span>,\n  <span class="hljs-string">"content"</span>:<span class="hljs-string">"Example Content"</span>,\n  <span class="hljs-string">"__v"</span>:<span class="hljs-number">0</span>\n}\n</code></pre>\n<h4><a href="https://mustardamus.github.io/teil/guide/route-data-validation">Read more about Route Data Validation</a></h4>\n<h3>Data validation in model schemas</h3>\n<p>Mongoose supports\n<a href="http://mongoosejs.com/docs/validation.html#custom-validators">custom validations</a>\nout of the box. Teil extends this with many validations provided by\n<a href="https://github.com/chriso/validator.js">Validator.js</a>.</p>\n<p>Lets add a optional <code>authorEmail</code> field to the <code>Author</code> model at\n<code>./models/author.js</code>:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./models/article.js</span>\n<span class="hljs-built_in">module</span>.exports = {\n  schema ({ <span class="hljs-attr">validator</span>: { isEmail } }) {\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">title</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },\n      <span class="hljs-attr">content</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },\n\n      <span class="hljs-attr">authorEmail</span>: {\n        <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,\n        <span class="hljs-attr">validate</span>: {\n          <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.length === <span class="hljs-number">0</span> || isEmail(val),\n          <span class="hljs-attr">message</span>: <span class="hljs-string">\'{VALUE} is not a valid E-Mail\'</span>\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>As you can see, the <code>schema</code> isn\'t an Object anymore, but a Function that is\nusing destructuring again. This Function must return the schema Object.</p>\n<p>For <code>title</code> and <code>content</code> the <code>required</code> validation that Mongoose is providing\nis used.</p>\n<p>We added a new <code>authorEmail</code> field. There we make use of Mongoose\'s custom\nvalidations. On top of that we use the <code>isEmail</code> validator from Validator.js,\nand make it optional by checking the length of the string.</p>\n<p>Since we already validating data on the route, we need to extend that schema as\nwell, in <code>./controllers/authors.js</code>:</p>\n<pre><code class="hljs language-javascript">body: {\n  <span class="hljs-attr">title</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n  <span class="hljs-attr">content</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n  <span class="hljs-attr">authorEmail</span>: <span class="hljs-string">\'string?\'</span>\n}\n</code></pre>\n<p>The <code>?</code> tells Superstruct that the value of <code>authorEmail</code> is an optional String.</p>\n<p>Lets try creating an article with an invalid <code>authorEmail</code>:</p>\n<pre><code class="hljs language-shell">curl -H "Content-Type: application/json" \\\n     -d \'{"title":"Example Post","content":"Example Content","authorEmail":"nope"}\' \\\n     -X POST http://localhost:3003/api/articles\n</code></pre>\n<p>This request is failing with a status code of <code>500</code> and is returning:</p>\n<pre><code class="hljs language-shell">Article validation failed: authorEmail: nope is not a valid E-Mail\n</code></pre>\n<p>Posting no <code>authorEmail</code> or a valid E-Mail works fine. Easy peasy.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/model-schema-validation">Read more about Model Schema Validation</a></h4>\n<h3>Create fully fledged Mongoose models by simple declarative objects</h3>\n<p>Mongoose models are powerful. Teil adds some abstraction to all the features and\nmakes it pretty simple to define fully fledged models.</p>\n<p>Lets add a <a href="http://mongoosejs.com/docs/api.html#Virtualtype">virtual field</a>\n<code>excerpt</code> for example by adding this to <code>./models/article.js</code>:</p>\n<pre><code class="hljs language-javascript">virtuals: {\n  <span class="hljs-attr">excerpt</span>: {\n    get () {\n      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.content === <span class="hljs-string">\'string\'</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.content.substr(<span class="hljs-number">0</span>, <span class="hljs-number">140</span>) + <span class="hljs-string">\'...\'</span>\n      }\n    }\n  }\n},\n\n<span class="hljs-attr">options</span>: {\n  <span class="hljs-attr">toObject</span>: { <span class="hljs-attr">virtuals</span>: <span class="hljs-literal">true</span> }\n}\n</code></pre>\n<p>Here <code>virtuals</code> is an Object that holds all virtual fields, the key name is also\nthe name of the virtual field, <code>excerpt</code> in this example. This field has a\ngetter, represented by the <code>get()</code> method.</p>\n<p>In this method we check if the type <code>content</code> of the document (<code>this</code>) is a\nString (remember, we\'ve created articles without content), and if so, return\nthe first 140 characters of the <code>content</code> value.</p>\n<p>Below the <code>virtuals</code> there is an <code>options</code> Object defined. We want the excerpt\nto be included when we return the document in JSON format. Therefore we set\nthe <code>virtuals</code> option of\n<a href="http://mongoosejs.com/docs/api.html#document_Document-toObject">toObject</a> to\n<code>true</code>.</p>\n<h4><a href="https://mustardamus.github.io/teil/guide/model-declaration">Read more about Model Declaration</a></h4>\n<ul>\n<li>Make use of destructuring to have tight controllers</li>\n<li>Create fully fledged Mongoose models by simple objects</li>\n<li>Validate and alter data when its leaving your routes</li>\n<li>Automatically load middleware</li>\n<li>Lovely logging</li>\n<li>Includes ready to use libraries like Lodash, Validator.js and Superstruct</li>\n<li>All configurable via a single file</li>\n</ul>\n<h2>Create a simple Blog in 5 minutes</h2>\n<p>You\'ll need to have Node.js, NPM and MongoDB installed.</p>\n<h3>Initialize a new Teil project</h3>\n<pre><code class="hljs language-bash">mkdir teil-blog\n<span class="hljs-built_in">cd</span> teil-blog\nyarn init -y\nyarn add teil\n</code></pre>\n<p>In the <code>package.json</code>, add the <code>dev</code> command:</p>\n<pre><code class="hljs language-json"><span class="hljs-string">"scripts"</span>: {\n  <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"teil"</span>\n}\n</code></pre>\n<p>And start the app:</p>\n<pre><code class="hljs language-bash">yarn dev\n</code></pre>\n<h3>Create a <code>Post</code> model</h3>\n<p>Create the file <code>models/post.js</code> with the following code:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">options</span>: {\n    <span class="hljs-attr">timestamps</span>: <span class="hljs-literal">true</span>\n  },\n\n  <span class="hljs-attr">schema</span>: {\n    <span class="hljs-attr">title</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },\n    <span class="hljs-attr">content</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> },\n\n    <span class="hljs-attr">excerpt</span>: {\n      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,\n      <span class="hljs-attr">validate</span>: {\n        <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.length &lt;= <span class="hljs-number">140</span>,\n        <span class="hljs-attr">message</span>: <span class="hljs-string">\'Excerpt must not exceed 140 characters\'</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p>If your MongoDB weren\'t started already, Teil would do that for you. The new\nmodel is picked up automatically and is ready to use in controllers.</p>\n<p>Note that we use Mongoose\'s option to automatically create timestamps for us.</p>\n<p>Also note how we define a Mongoose schema in the model and define a custom\nvalidator for the <code>excerpt</code> field.</p>\n<h3>Create a <code>Posts</code> controller</h3>\n<p>Create the file <code>controllers/posts.js</code> with the following code:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-string">\'GET /\'</span> ({ send }) {\n    send(<span class="hljs-string">\'index route\'</span>)\n  },\n\n  <span class="hljs-string">\'POST /create\'</span> ({ send }) {\n    send(<span class="hljs-string">\'create route\'</span>)\n  }\n}\n</code></pre>\n<p>Teil will automatically set up the routes for you at\n<a href="http://localhost:3003/api/posts">/api/posts</a> and\n<a href="http://localhost:3003/api/posts/create">/api/posts/create</a>.</p>\n<p>The filename is used as the resource-name, <code>posts</code>, in the route. Each exported\nfunction has a name formatted as <code>[http-method] [express-route]</code>, and will\nautomatically mount under the parent resource in a RESTful way.</p>\n<p>Note that we use destructuring in the first parameter of the function. <code>send</code>\nis the same as <code>res.send</code> if we would use traditional Express.js callbacks.</p>\n<h3>Creating a <code>Post</code></h3>\n<p>Update the <code>POST /create</code> route like so:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'POST /create\'</span> ({ send, body, Post }) {\n  <span class="hljs-keyword">const</span> post = <span class="hljs-keyword">new</span> Post(body)\n  post.save().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> send(post))\n}\n</code></pre>\n<p>As you can see we get the <code>body</code> object from the context. This is the same as\n<code>req.body</code> if we would traditional Express.js callbacks. This object contains\nthe <code>POST</code>ed data.</p>\n<p>Next we get the <code>Post</code> model from the context. This is the Mongoose model we\nhave created just a second ago.</p>\n<p>We create a new <code>Post</code> with the posted data and send back the object.</p>\n<p>Lets try it out with <code>curl</code>:</p>\n<pre><code class="hljs language-bash">curl -H <span class="hljs-string">"Content-Type: application/json"</span> \\\n     -d <span class="hljs-string">\'{"title":"Post 1","excerpt":"Post 1 excerpt","content":""}\'</span> \\\n     -X POST http://localhost:3003/api/posts/create\n</code></pre>\n<p>This will, as expected, return:</p>\n<pre><code class="hljs language-json">{\n  <span class="hljs-attr">"_id"</span>:<span class="hljs-string">"5a6a0a74665a830d56bfe362"</span>,\n  <span class="hljs-attr">"title"</span>:<span class="hljs-string">"Post 1"</span>,\n  <span class="hljs-attr">"excerpt"</span>:<span class="hljs-string">"Post 1 excerpt"</span>,\n  <span class="hljs-attr">"content"</span>:<span class="hljs-string">""</span>,\n  <span class="hljs-attr">"createdAt"</span>:<span class="hljs-string">"2018-01-25T16:48:52.620Z"</span>,\n  <span class="hljs-attr">"updatedAt"</span>:<span class="hljs-string">"2018-01-25T16:48:52.620Z"</span>,\n  <span class="hljs-attr">"__v"</span>:<span class="hljs-number">0</span>\n}\n</code></pre>\n<h3>Adding <code>body</code> validation</h3>\n<p>In our <code>Post</code> model we defined earlier, we forgot to set the <code>required</code>\nvalidation to the <code>content</code> field. That\'s why we could create a <code>Post</code> without\ncontent.</p>\n<p>For the sake of this example, lets not add that validation to the model, but to\nthe route.</p>\n<p>Change the <code>POST /create</code> route to:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'POST /create\'</span>: [\n  {\n    <span class="hljs-attr">body</span>: {\n      <span class="hljs-attr">title</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n      <span class="hljs-attr">excerpt</span>: <span class="hljs-string">\'isNotEmpty\'</span>,\n      <span class="hljs-attr">content</span>: <span class="hljs-string">\'isNotEmpty\'</span>\n    }\n  },\n  ({ send, body, Post }) =&gt; {\n    <span class="hljs-keyword">const</span> post = <span class="hljs-keyword">new</span> Post(body)\n    post.save().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> send(post))\n  }\n]\n</code></pre>\n<p>Note that <code>POST /create</code> is now an Array instead of a Function. We moved our\nroute handler Function to the end of the Array. The first Array item is an\nObject that defines the validations we want to perform.</p>\n<p>In this example we want to validate the <code>body</code> data. Each field should not be\nempty.</p>\n<p>Lets try creating a <code>Post</code> with a empty <code>content</code> field again:</p>\n<pre><code class="hljs language-bash">curl -H <span class="hljs-string">"Content-Type: application/json"</span> \\\n     -d <span class="hljs-string">\'{"title":"Post 2","excerpt":"Post 2 excerpt","content":""}\'</span> \\\n     -X POST http://localhost:3003/api/posts/create\n</code></pre>\n<p>The request will fail with a 500 status and returns:</p>\n<pre><code class="hljs">Expected a value of<span class="hljs-built_in"> type </span>`isNotEmpty` <span class="hljs-keyword">for</span> `content` but received `<span class="hljs-string">""</span>`.\n</code></pre>\n<p>Enter some content and the request will succeed as before returning the <code>Post</code>s\ndata.</p>\n<h3>Listing all the posts</h3>\n<p>Now lets update the <code>GET /</code> route like so:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'GET /\'</span> ({ send, Post }) {\n  Post.find().exec().then(<span class="hljs-function"><span class="hljs-params">posts</span> =&gt;</span> send(posts))\n}\n</code></pre>\n<p>Navigate to <a href="http://localhost:3003/api/posts">/api/posts</a> to see all the <code>Post</code>s\nwe have created so far. Easy peasy.</p>\n<h3>Altering the response data</h3>\n<p>Lets say in our index route we only want to return a bare minimum on data for\neach <code>Post</code>.</p>\n<p>Change the <code>GET /</code> route like so:</p>\n<pre><code class="hljs language-javascript"><span class="hljs-string">\'GET /\'</span>: [\n  {\n    response ({ data, <span class="hljs-attr">_</span>: { pick } }) {\n      <span class="hljs-keyword">return</span> data.map(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> pick(post, <span class="hljs-string">\'_id\'</span>, <span class="hljs-string">\'title\'</span>, <span class="hljs-string">\'excerpt\'</span>))\n    }\n  },\n  ({ send, Post }) =&gt; {\n    Post.find().exec().then(<span class="hljs-function"><span class="hljs-params">posts</span> =&gt;</span> send(posts))\n  },\n],\n</code></pre>\n<p>This is the same Array style we have created for the other route, the first item\nis an Object that defines validations, and the second one is the route handler\nFunction.</p>\n<p>Note that instead of a validation Object, we define <code>response</code> as a function. We\npass in the <code>data</code> that is send back, as well as the <code>pick</code> Function from\nLodash.</p>\n<p>We <code>map</code> each <code>Post</code> and use the <code>pick</code> Function to only pick the fields we\nactually want to return.</p>\n<p>Navigate to <a href="http://localhost:3003/api/posts">/api/posts</a> and see the much\nslimmer response.</p>\n<h2>Development</h2>\n<h3>Commands (<code>yarn *</code>)</h3>\n<h4><code>test</code></h4>\n<p>Runs the tests.</p>\n<h4><code>test:watch</code></h4>\n<p>Re-run tests on file changes.</p>\n<h4><code>lint</code></h4>\n<p>Linting all the code.</p>\n<h4><code>docs:dev</code></h4>\n<p>Starts the <code>./docs</code> Nuxt app on <a href="http://localhost:9991">localhost:9991</a>.</p>\n<h4><code>docs:generate</code></h4>\n<p>Generate a static version of the documentation.</p>\n<h4><code>docs:publish</code></h4>\n<p>Publish the generated documentation to <code>gh-pages</code>.</p>\n<h4><code>docs</code></h4>\n<p>Run <code>docs:generate</code> and <code>docs:publish</code> in sequence.</p>\n<h3><code>example</code></h3>\n<p>Runs the full example in <code>./example</code>.</p>\n</section>\n'},MT1B:function(e,s,a){"use strict";var n=function(){var e=this.$createElement;return(this._self._c||e)("div",{domProps:{innerHTML:this._s(this.readMe)}})};n._withStripped=!0;var t={render:n,staticRenderFns:[]};s.a=t},yFkh:function(e,s,a){"use strict";var n=a("G0wi"),t=a.n(n);s.a={computed:{readMe:function(){return t.a}}}}});